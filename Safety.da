import Ledger
import nacl.hash
import BlockTree
import Safety  # to get validator id for logging
from nacl.exceptions import BadSignatureError
from nacl.signing import SigningKey
from nacl.signing import VerifyKey

# SAFETY: PRIVATE

# these get assigned during process setup
_private_key = None
_public_keys = None


f = None
validator_id = None
validators = None
validator_map = None

highest_vote_round = 0  # initially 0
highest_qc_round = 0    # initially 0 (genesis QC)


# set process private key (called during setup)
def set_private_key(key):
    global _private_key
    _private_key = key


def get_private_key():
    return _private_key


# set process public keys (caled during setup)
def set_public_keys(keys):
    global _public_keys
    _public_keys = keys


# get public key of a validator
def get_public_key(val):
    if val not in _public_keys:
        print(f"{Safety.validator_id}: Validator: {val} public key not found")
        return
    else:
        return _public_keys[val]


# set process validator_id (called during setup)
# def set_validator_id(id):
    #global _validator_id
    #_validator_id = id


def _increase_highest_vote_round(round):
    # commit not to vote in rounds lower than round
    global highest_vote_round
    highest_vote_round = max(round, highest_vote_round)


def _update_highest_qc_round(qc_round):
    global highest_qc_round
    highest_qc_round = max(qc_round, highest_qc_round)


def _consecutive(block_round, round):
    #print(f"{Safety.validator_id}: Inside Safety._consecutive.")
    return round + 1 == block_round


def _safe_to_extend(block_round, qc_round, tc):
    #print(f"{Safety.validator_id}: Inside Safety._safe_to_extend")
    if tc == None:
        print("Discarding message: No TC")
        return False
    return _consecutive(block_round, tc.round) and (qc_round >= max(tc.tmo_high_qc_rounds))


def _safe_to_vote(block_round, qc_round, tc):
    #print(f"{Safety.validator_id}: Inside Safety._safe_to_vote. Block Round:{block_round},QC Round:{qc_round}")

    global highest_vote_round
    if block_round <= max(highest_vote_round, qc_round):
        # 1. must vote in monotonically increasing rounds
        # 2. must extend a smaller round
        return False
    return _consecutive(block_round, qc_round) or _safe_to_extend(block_round, qc_round, tc)


def _safe_to_timeout(round, qc_round, tc):
    #print(f"{Safety.validator_id}: Inside Safety_safe_to_timeout.")
    global highest_qc_round, highest_vote_round
    if (qc_round < highest_qc_round) or (round <= max(highest_vote_round - 1, qc_round)):
        # respect highest_qc_round and don't timeout in a past round
        print(f"{Safety.validator_id}: CANT TIMEOUT IN PAST ROUND => rnd:{round},qcrnd:{qc_round},highest_qc_round{highest_qc_round},highestvoteround:{highest_vote_round}")
        return False
    return _consecutive(round, qc_round) or _consecutive(round, tc.round)


def _commit_state_id_candidate(block_round, qc):
    # find the commited id in case a qc is formed in the vote round
    if _consecutive(block_round, qc.vote_info.round):
        # Should we add check here to make sure we don't return a commitstateid for genesis qc?
        return Ledger.pending_state(qc.vote_info.id)
    else:
        return None


def _valid_signature(key, signature):
    #print(f"Inside Safety._valid_signature. {Safety.validator_id}")
    try:
        valid_signature = key.verify(signature)
    except BadSignatureError:
        print(
            f"{Safety.validator_id}: Discarding message: Signature was forged or corrupted.")
        return False
    return True


def _valid_signatures_make_vote(b, last_tc):
    return _valid_signatures(b.qc, last_tc)


def _valid_signatures(qc, last_tc):
    # perform signature checking
    #print(f"Inside Safety._valid_signatures. {Safety.validator_id}")
    global f, _validator_id

    if last_tc:
        if len(last_tc.tmo_signatures) < 2 * f + 1:
            print(
                f"{Safety.validator_id}: Discarding message: TC does not have a quorum of signatures.")
            return False
        for sender, signature in last_tc.tmo_signatures:
            # verify each signature
            if sender not in _public_keys:
                print(
                    f"{Safety.validator_id}: Discarding message: Unknown signature in TC.")
                return False
            if not _valid_signature(_public_keys[sender], signature):
                return False

    # now check signatures within the block (qc)

    if qc.vote_info.round == 0:
        # genesis qc, don't have any signatures to check
        return True
    if qc.author not in _public_keys:
        # this implementation requires validators to also keep thier own public key in public_keys,
        # since it's possible that the received qc could be authored by itself in the case of multiple
        # view changes
        print(f"{Safety.validator_id}: Discarding message: Unknown author.")
        return False
    if not _valid_signature(_public_keys[qc.author], qc.author_signature):
        return False
    if len(qc.signatures) < 2 * f + 1:
        print(
            f"{Safety.validator_id}: Discarding message: QC does not have a quorum of signatures.")
        return False
    for sender, signature in qc.signatures:
        if sender not in _public_keys:
            print(
                f"{Safety.validator_id}: Discarding message: Unknown signature in QC")
            return False
        if not _valid_signature(_public_keys[sender], signature):
            return False

    return True


# SAFETY: PUBLIC


def make_vote(b, last_tc):
    # b is the block to vote on
    # last_tc is the timeout certificate for the previous round, else âŠ¥
    #print(f"{Safety.validator_id}: Inside Safety.make_vote.")

    qc_round = b.qc.vote_info.round
    if _valid_signatures_make_vote(b, last_tc) and _safe_to_vote(b.round, qc_round, last_tc):
        _update_highest_qc_round(qc_round)
        _increase_highest_vote_round(b.round)
        exec_state_id = Ledger.pending_state(b.id)
        vote_info = BlockTree.VoteInfo(id=b.id, round=b.round, parent_id=b.qc.vote_info.id, parent_round=qc_round,
                                       exec_state_id=exec_state_id)

        vote_info_hash = nacl.hash.sha256((str(b.id) + str(b.round) + "-" +
                                           str(b.qc.vote_info.id) + str(qc_round) + "-" + exec_state_id).encode(),
                                          nacl.encoding.HexEncoder).decode()

        ledger_commit_info = BlockTree.LedgerCommitInfo(commit_state_id=_commit_state_id_candidate(
            b.round, b.qc), vote_info_hash=vote_info_hash)

        return BlockTree.VoteMsg(vote_info, ledger_commit_info, BlockTree.high_commit_qc)
    else:
        return None


def make_timeout(round, high_qc, last_tc):
    # Make a TimeoutInfo after a local timeout

    global validator_id, _private_key
    qc_round = high_qc.vote_info.round
    if _valid_signatures(high_qc, last_tc) and _safe_to_timeout(round, qc_round, last_tc):
        _increase_highest_vote_round(round)  # stop voting for round
        if _private_key == None:  # make sure you have a private key to perform signature
            print(f" {Safety.validator_id}: No private key given.")
            return None
        else:
            signature = _private_key.sign((round, high_qc.vote_info.round))
        return BlockTree.TimeoutInfo(round, high_qc, validator_id)
    else:
        return None
