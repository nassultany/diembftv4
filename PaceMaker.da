import time
import BlockTree
import Safety
import Validator
from collections import defaultdict

#current_round = 0
current_round = 1
last_round_tc = None
pending_timeouts = defaultdict(list)
delta = 1


# time_started = 0
# time_stopped = 0


def get_round_timer(r):
    #print(f"{Safety.validator_id}: In function: PaceMaker.get_round_timer")
    # need to figure out formula
    return 4 * delta


def start_timer(new_round):
    #print(f"{Safety.validator_id}: In function: PaceMaker.start_timer")
    global current_round
    stop_timer(current_round)
    current_round = new_round
    print(f"{Safety.validator_id}: Timer started for round: {current_round}")
    # start local timer for round current round for duration get round timer(current round)
    # time_started = time.perf_counter()


def local_timeout_round():
    global current_round
    #print(f"{Safety.validator_id}: In function: PaceMaker.local_timeout_round")
    save_consensus_state()
    timeout_info = Safety.make_timeout(
        current_round, BlockTree.high_qc, last_round_tc)
    #broadcast(BlockTree.TimeoutMsg(timeout_info,last_round_tc, BlockTree.high_commit_qc))
    # Can't actually send message from here, instead return it to validator and send it from there
    return BlockTree.TimeoutMsg(timeout_info, last_round_tc, BlockTree.high_commit_qc)


def process_remote_timeout(tmo):
    # tmo is a timeout message
    #print(f"{Safety.validator_id}: In function: PaceMaker.process_remote_timeout. {Safety.validator_id}")
    global current_round, pending_timeouts
    tmo_info = tmo.tmo_info
    if tmo_info.round < current_round:
        return None, None
    if len(pending_timeouts[tmo_info.round]) == 0:
        pending_timeouts[tmo_info.round].append(tmo_info)
        return None, None
    try:
        senders = [thetmo.sender for thetmo in pending_timeouts[tmo_info.round]]
    except:
        print(f"\t\t\t\t\tFAILED HERE {Safety.validator_id}")
    if tmo_info.sender not in senders:
        pending_timeouts[tmo_info.round].append(tmo_info)

    # if len(pending_timeouts[tmo_info.round].senders) == BlockTree.f + 1:
    if len(pending_timeouts[tmo_info.round]) == BlockTree.f + 1:
        stop_timer(current_round)
        # local_timeout_round()  # bracha timeout
        return None, local_timeout_round()
    # if len(pending_timeouts[tmo_info.round].senders) == 2 * BlockTree.f + 1:
    if len(pending_timeouts[tmo_info.round]) == 2 * BlockTree.f + 1:
        high_qc_rounds = []
        for info in pending_timeouts[tmo_info.round]:
            high_qc_rounds.append(info.high_qc.vote_info.round)
        signatures = []
        for info in pending_timeouts[tmo_info.round]:
            signatures.append((info.sender, info.signature))
        return BlockTree.TC(tmo_info.round, high_qc_rounds, signatures), None
    return None, None


def stop_timer(r):
    # global time_stopped
    #print(f"{Safety.validator_id}: In function: PaceMaker.stop_timer")
    # time_stopped = time.perf_counter()
    pass


def advance_round_tc(tc):
    #print(f"{Safety.validator_id}: In function: PaceMaker.advance_round_tc. {Safety.validator_id}")
    global current_round, last_round_tc
    if tc is None or tc.round < current_round:
        return False
    last_round_tc = tc
    start_timer(tc.round + 1)
    return True


def save_consensus_state():
    #print(f"{Safety.validator_id}: In function: PaceMaker.save_consensus_state")
    pass


def advance_round_qc(qc):
    global current_round, last_round_tc
    #print(f"{Safety.validator_id}: In function: PaceMaker.advance_round_qc")
    if qc.vote_info.round < current_round:
        return False
    last_round_tc = None
    start_timer(qc.vote_info.round + 1)
    return True


def broadcast(msg):
    #print(f"{Safety.validator_id}: In function: PaceMaker.broadcast")
    # send a timeoutMsg to all other validators
    # for validator in LeaderElection.validators:
    Validator.send_message('TimeoutMsg', msg, Validator.validators)
