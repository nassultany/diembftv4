import time
import BlockTree
import Safety
import MemPool
import PaceMaker

current_round = 0
last_round_tc = None
pending_timeouts = {int:{}}
delta = None



# time_started = 0
# time_stopped = 0


def get_round_timer(r):
    print("In function: PaceMaker.get_round_timer")
    # need to figure out formula
    return 4 * delta


def start_timer(new_round):
    print("In function: PaceMaker.start_timer")
    global current_round
    stop_timer(current_round)
    current_round = new_round
    # start local timer for round current round for duration get round timer(current round)
    # time_started = time.perf_counter()


def local_timeout_round():
    global current_round
    print(f'\033[1;35m[Val{Safety.validator_id} {Safety.node_map[Safety.validator_id]}]In function: local_timeout_round\033[1;37m')
    save_consensus_state()
    timeout_info = Safety.make_timeout(current_round, BlockTree.high_qc, last_round_tc)
    broadcast(BlockTree.TimeoutMsg(timeout_info, last_round_tc, BlockTree.high_commit_qc))


def process_remote_timeout(tmo, sender):
    # tmo is a timeout message
    print(f'\033[1;35m[Val{Safety.validator_id} {Safety.node_map[Safety.validator_id]}]In function: process_remote_timeout\033[1;37m')
    global current_round, pending_timeouts
    tmo_info = tmo.tmo_info
    if tmo_info.rnd < current_round:
        return None

    print(f'\033[1;35m[Val{Safety.validator_id} {Safety.node_map[Safety.validator_id]}]flag is set to false\033[1;37m')
    flag = False
    if pending_timeouts.get(tmo_info.rnd, None) is None:
        x = set()
        x.add(tmo_info)
        pending_timeouts[tmo_info.rnd] = x
        print(f'\033[1;35m[Val{Safety.validator_id} {Safety.node_map[Safety.validator_id]}]If condition satisfied\033[1;37m')
    else:
        print(f'\033[1;35m[Val{Safety.validator_id} {Safety.node_map[Safety.validator_id]}]Else condition satisfied\033[1;37m')
        for info in pending_timeouts.get(tmo_info.rnd, None):
            if info.sender is sender:
                flag = True
                break
        if flag is False:
            print(f'\033[1;35m[Val{Safety.validator_id} {Safety.node_map[Safety.validator_id]}]Adding {tmo_info} at {tmo_info.rnd}\033[1;37m')
            pending_timeouts[tmo_info.rnd].add(tmo_info)

    print(f'\033[1;35m[Val{Safety.validator_id} {Safety.node_map[Safety.validator_id]}]Checking for round {tmo_info.rnd}\033[1;37m')

    #pending_timeouts.get((tmo_info.rnd, None)) is not None and
    print(f'\033[1;35m[Val{Safety.validator_id} {Safety.node_map[Safety.validator_id]}]Checking for\
        {len(pending_timeouts[tmo_info.rnd])} and {BlockTree.f}\033[1;37m')
    if len(pending_timeouts[tmo_info.rnd]) is (BlockTree.f + 1):
        print(f'\033[1;35m[Val{Safety.validator_id} {Safety.node_map[Safety.validator_id]}]^^^^^^^^^^^^^^^^^^^^^Starting local timeout as^^^^^^^^^^^^^^^^^^^^^^^^^^{BlockTree.f+1} TO messages have been received\033[1;37m')
        stop_timer(current_round)
        local_timeout_round()

    if len(pending_timeouts[tmo_info.rnd]) is (2*BlockTree.f + 1):
        print(f'\033[1;35m[Val{Safety.validator_id} {Safety.node_map[Safety.validator_id]}]Attempt Creating a TC\033[1;37m')
        high_qc_rounds = []
        for info in pending_timeouts[tmo_info.rnd]:
            high_qc_rounds.append(info.high_qc)
        signatures = []
        for info in pending_timeouts[tmo_info.rnd]:
            signatures.append([info.sender, info.signature])
        print(f'\033[1;35m[Val{Safety.validator_id} {Safety.node_map[Safety.validator_id]}]$$$$$$$$$$$$$$$$$$$$Creating a TC$$$$$$$$$$$$$$$$$$$\033[1;37m')
        return BlockTree.TC(tmo_info.rnd, high_qc_rounds, signatures)
    return None


def stop_timer(r):
    # global time_stopped
    print("In function: PaceMaker.stop_timer")
    # time_stopped = time.perf_counter()


def advance_round_tc(tc):
    print("In function: PaceMaker.advance_round_tc")
    global current_round, last_round_tc
    if tc is None or tc.rnd < current_round:
        print(f'\033[1;35m[Val{Safety.validator_id} {Safety.node_map[Safety.validator_id]}]Returning false\033[1;37m')
        return False
    last_round_tc = tc
    start_timer(tc.rnd + 1)
    return True


def save_consensus_state():
    print("In function: PaceMaker.save_consensus_state")
    pass


def advance_round_qc(qc):
    global current_round, last_round_tc
    print("In function: PaceMaker.advance_round_qc")
    if qc is None:
        return True
    if qc.vote_info.rnd < current_round:
        return False
    last_round_tc = None
    start_timer(qc.vote_info.rnd+1)
    return True


def broadcast(M):
    print(f'\033[35m[Val{Safety.validator_id} {Safety.node_map[Safety.validator_id]}]Broadcasting timeout message\033[1;37m')
    # send a timeoutMsg to all other validators
    # for validator in LeaderElection.validators:
    MemPool.send_message("TimeoutMsg", M, Safety.other_validators)
