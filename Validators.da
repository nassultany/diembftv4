# change definition of send messages everywhere
import sys
from BlockTree import *
from LeaderElection import *
from Ledger import *
from MemPool import *
from Pacemaker import *
from Safety import *

config(channel='fifo', clock='Lamport')

<<<<<<< HEAD:Validators.da
class Validator(process):
    def setup(validators:set, exit_cnt:int): pass

    #sends a message to another validator
    def send_message(msg_type, msg_object):
        send((msg_type, msg_object, self))
=======

class Run(process):
    def setup(validators: set):
        pass
>>>>>>> 2f5f926e5e15b275ff01c09930fa30b641bc0f96:Run.da

    def process_certificate_qc(qc):
        output('In function: process_certificate_qc')
        BlockTree.process_qc(qc)
        LedgerElection.update_leaders(qc)
        Pacemaker.advance_round(qc.vote_info.rnd)

    def process_proposal_msg(P, sender):
        output('In function: process_proposal_msg')
        process_certificate_qc(P.block.qc)
        process_certificate_qc(P.high_commit_qc)
        Pacemaker.advance_round_tc(P.last_round_tc)
        current_round = Pacemaker.current_round
        leader = LeaderElection.get_leader(current_round)
        if (P.block.round is not current_round) or (sender is not leader) or (bl.author is not leader):
            return
        BlockTree.execute_and_insert(block)
        vote_msg = Safety.make_vote(block, last_round_tc)
        if vote_msg is None:
            send(("VoteMsg", vote_msg, self), to=LeaderElection.get_leader(rnd + 1))

    def process_timeout_msg(M):
        output('In function: process_timeout_msg')
        process_certificate_qc(M.tmo_info.high_qc)
        process_certificate_qc(M.high_commit_qc)
        Pacemaker.advance_round_tc(M.last_round_tc)
        tc = Pacemaker.process_remote_timeout(M)
        if tc is not None:
            Pacemaker.advance_round(tc)
            process_new_round_event(tc)

    def process_vote_msg(M):
        output('In function: process_vote_msg')
        qc = BlockTree.process_vote(M)
        if qc is not None:
            process_certificate_qc(qc)
            process_new_round_event(None)

    def process_new_round_event(last_tc):
        output('In function: process_new_round_event')
        if u is LeaderElection.get_leader(Pacemaker.current_round):
            b = BlockTree.generate_block(MemPool.get_transactions(), Pacemaker.current_round)
            if (b.payload == "Exit"):
                exit_cnt += 1
            if exit_cnt is 3:
		sys.exit("No more requests from client")
            P = BlockTree.ProposalMsg(b, last_tc, BlockTree.high_commit_qc)
            send(("ProposalMsg", P, self), to=validators)

    def receive(msg=("ProposalMsg", P, sender)):
        process_proposal_msg(P, sender)

    def receive(msg=("TimeoutMsg", M, sender)):
        process_timeout_msg(M)

    def receive(msg=("VoteMsg", M, sender)):
        process_vote_msg(M)

    def receive(msg=("LocalTimeout", M, sender)):
        Pacemaker.local_timeout_round()

    def run():
        op = 'Starting Node ' + Safety.validator_id
        output(op)
        while exit_cnt<3:
            continue
