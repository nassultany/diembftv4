import nacl.encoding
import nacl.hash
import BlockTree
import Safety
from collections import deque


u = None
filename = None
#f = open(filename, "w+")
# f.close()
commits = {}
q_size = 4  # no of committed blocks remembered
commit_queue = deque()  # stores the last q_size committed blocks
state_id = {}  # description below:
# stores exec_state_id with index as block_id
# stores hash of the exec_state_id of the previous block and transactions of the current block
# commit_state_id can also be obtained from this by referring to the previous block ids
# This is taken care of in the Safety Module when it asks for state_id to populate its LedgerCommitInfo.commit_state_id
# Hence not dealt with here
#print(f"database for validator {u} created")

# We're NOT maintaining a separate pending tree in Ledger as mentioned in the phase 2 document
# We're just executing txns on whatever exists in the file and returning the hash of file contents


def setup_Ledger():
    global u, filename
    u = Safety.validator_id
    filename = "database"+str(u)+".txt"
    f = open(filename, 'w+')
    f.close()
    # Add root of speculative ledger tree, corresponding to genesis block
    state_id[BlockTree.genesis_block.id] = nacl.hash.sha256(
        "666999".encode()).decode()
    commits[BlockTree.genesis_block.id] = BlockTree.genesis_block


def speculate(prev_block_id, block_id, txns):
    global state_id
    #print(f"{Safety.validator_id}: In function: Ledger.speculate.")

    # if BlockTree.pending_block_tree[1].root is prev_block_id:
    #    state_id[block_id] = nacl.hash.sha256([state_id[prev_block_id], txns],
    #                                          encoder=nacl.encoding.HexEncoder)
    # else:
    #    print("Inconsistency in validator: {u}")

    # Apply transactions speculatively and add to speculative ledger state
    state_id[block_id] = nacl.hash.sha256(
        (state_id[prev_block_id]+txns).encode()).decode()


def commit(block_id):
    #print(f"{Safety.validator_id}: In function: Ledger.commit")
    # if block_id in BlockTree.pending_block_tree.blocks:
    #bl = BlockTree.pending_block_tree[0].blocks[block_id]
    #f = open(filename, "a")
    # f.append(bl.payload)
    # f.close()
    #commits[block_id] = bl
    # deque.append(bl)
    #print("Committed block {block_id}")
    # if len(commit_queue) > q_size:
    #    commits.pop(commits[commit_queue[0]])
    #    commit_queue.pop_left()
    # return state_id

    if block_id not in BlockTree.pending_block_tree:
        #print(f"{Safety.validator_id}: Invalid block id to commit")
        return
    block = BlockTree.pending_block_tree[block_id].block
    f = open(filename, 'a')
    f.write(block.payload)
    f.close()
    commits[block_id] = block
    return block.payload


def committed_block(block_id):
    return commits[block_id]


def pending_state(block_id):
    return state_id[block_id]
