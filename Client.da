from datetime import datetime
from nacl.signing import SigningKey
from nacl.signing import VerifyKey
import nacl.hash
from time import sleep

config(channel='fifo', clock='Lamport')


class Request:
    def __init__(self, id, cmd, client, signature):
        self.id = id  # request id for deduplication and caching of results
        # It is assumed that commands are of the form str(c)+"-"+str(i), where i refers
        # to the ith command from client c.
        self.cmd = cmd
        self.client = client  # the actual process of the client. Used to send the reply
        self.signature = signature  # signature(id)


class Workload:
    def __init__(self, numrequests, delay, retransmit):
        self.numrequests = numrequests
        self.delay = delay
        self.retransmit = retransmit


class Client(process):
    def setup(config):
        output("Setting up client")
        # setup the client
        # config is a dictionary with config information
        self.work_load = config["workload"]
        self.validators = config["validators"]
        self.private_key = config['private_key']
        self.replies = {}
        self.f = config['f']  # faulty validators
        self.timeout = config['timeout']  # wait for 2f+1 replies

    def receive(msg=('reply', reply), from_=p):
        print(f"Received reply from {p} for RequestID: {reply[0]}")
        if reply[0] in replies:
            replies[reply[0]].append(reply[1])
        else:
            replies[reply[0]] = [reply[1]]

    def run():
        for i in range(1, work_load.numrequests + 1):
            sleep(work_load.delay)
            # send the request
            client = self
            cmd = str(self) + "-" + str(i)+"\n"
            req_hash = nacl.hash.sha256(cmd.encode())
            reqid = i
            signature = private_key.sign(req_hash)
            req = Request(reqid, cmd, client, signature)
            print(f"Sending request to validators:{validators}")
            send(('Request', req), to=validators)
            replies[i] = []
        #    -- reply
        #    # limitation: doesn't make sure replies are from unique validators
        #    if await(len(replies[i]) == 2 * f + 1):
        #        print(f"{cmd} was committed, result:{replies[i][0]}")
        #        continue
        #    elif timeout(timeout):
        #        # retransmit request
        #        print("retransmitting due to timeout")

        output(f"\t\t\t\t\t\t\t\tFinished workload and exiting")
        # in main, you can use await(each(c in clients, has=received(('finished_workload',), from_=c)))
        # in order to determine when all clients have finished their workloads and you can tell
        # validators to exit
        send(('finished_workload',), to=nodeof(self))
