from datetime import datetime
from nacl.signing import SigningKey
from nacl.signing import VerifyKey
import nacl.hash
from time import sleep

config(channel='fifo', clock='Lamport')
print('Setting up client')


class Request:
    def __init__(self, id, cmd, client, signature):
        self.id = id  # request id for deduplication and caching of results
        # It is assumed that commands are of the form str(c)+"-"+str(i), where i refers
        # to the ith command from client c.
        self.cmd = cmd
        self.client = client  # the actual process of the client. Used to send the reply
        self.signature = signature  # signature(id)


class Workload:
    def __init__(self, numrequests, delay, retransmit):
        self.numrequests = numrequests
        self.delay = delay
        self.retransmit = retransmit


class Client(process):
    def setup(config):
        print("Setting up client")
        # setup the client
        # config is a dictionary with config information
        self.work_load = config["workload"]
        self.validators = config["validators"]
        self.private_key = config['private_key']
        self.replies = {}
        self.f = config['f']  # faulty validators
        self.timeout = config['timeout']  # wait for 2f+1 replies

    def receive(msg=('reply', reply, q), from_=p):
        print(f'\033[1;32m %%%%%%%%%%%%%%%%%%%%%[Client{self}] Received reply from Validator{p}\033%%%%%%%%%%%%%%%%%%%%%%%%%%%%%[1;37m')
        if reply[0] in replies:
            replies[reply[0]].append(reply[1])
        else:
            replies[reply[0]] = [reply[1]]

    def run():
        for i in range(1, work_load.numrequests + 1):
            #sleep(work_load.delay)
            # send the request
            client = self
            cmd = str(self) + " --- " + str(i)
            reqid = nacl.hash.sha256(cmd.encode())
            reqid_str = reqid.decode()
            signature = private_key.sign(reqid)
            req = Request(reqid_str, cmd, client, signature)
            print(f"Sending request to validators:{validators}")
            send(("Request", req, self), to=validators)
            replies[reqid_str] = []
            -- reply
            # limitation: doesn't make sure replies are from unique validators
            if await(len(replies[reqid_str]) == 2 * f + 1):
                print(f"{cmd} was committed, result:{replies[reqid_str][0]}")
                continue
            elif timeout(timeout):
                # retransmit request
                print("retransmitting due to timeout")

        print("Finished workload and exiting")
        # in main, you can use await(each(c in clients, has=received(('finished_workload',), from_=c)))
        # in order to determine when all clients have finished their workloads and you can tell
        # validators to exit
        send(('finished_workload',), to=nodeof(self))
