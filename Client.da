import nacl.hash
from datetime import datetime
from nacl.signing import SigningKey
from nacl.signing import VerifyKey
from time import sleep

config(channel='fifo', clock='Lamport')


class Request:
    def __init__(self, id, cmd, client, signature):
        self.id = id  # request id for deduplication and caching of results
        # It is assumed that commands are of the form str(c)+"-"+str(i), where i refers
        # to the ith command from client c.
        self.cmd = cmd
        self.client = client  # the actual process of the client. Used to send the reply
        self.signature = signature  # signature(id)


class Workload:
    def __init__(self, numrequests, delay, retransmit):
        self.numrequests = numrequests
        self.delay = delay
        self.retransmit = retransmit


class Client(process):
    def setup(config):
        output("Setting up client")
        # setup the client
        # config is a dictionary with config information
        self.work_load = config["workload"]
        self.validators = config["validators"]
        self.private_key = config['private_key']
        self.replies = {}
        self.f = config['f']  # faulty validators
        self.timeout = config['timeout']  # wait for 2f+1 replies

    def receive(msg=('Reply', (reqid, result)), from_=p):
        # print(f"Received reply from {p} for RequestID: {reqid}")
        if reqid in replies:
            replies[reqid].append(result)
        else:
            replies[reqid] = [result]

    def run():
        for i in range(1, work_load.numrequests + 1):
            sleep(work_load.delay)
            # send the request
            client = self
            cmd = str(self) + "-" + str(i) + "\n"
            req_hash = nacl.hash.sha256(cmd.encode())
            reqid = i
            signature = private_key.sign(req_hash)
            req = Request(reqid, cmd, client, signature)
            # output(f"Sending request to validators:{validators}")
            output("Sending request to validators.")
            send(('Request', req), to=validators)
            replies[i] = []
            -- reply
            # limitation: doesn't make sure replies are from unique validators
            pending_request = True
            while pending_request:
                if await(len(replies[i]) == 2 * f + 1):
                    output(f"{cmd[:-1]} was committed.")
                    pending_request = False
                elif timeout(timeout):
                    # retransmit request
                    output(f"retransmitting {cmd} due to timeout")
                    send(('Request', req), to=validators)

        output(f"Finished workload and exiting")
        # in main, you can use await(each(c in clients, has=received(('finished_workload',), from_=c)))
        # in order to determine when all clients have finished their workloads and you can tell
        # validators to exit
        # sleep a couple of seconds to allow receival of validator replies (to prevent transport exception)
        sleep(2)
        send(('finished_workload',), to=nodeof(self))
