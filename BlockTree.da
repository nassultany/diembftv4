import Ledger
import Safety
from collections import defaultdict
import nacl.hash
import nacl.encoding
from collections import deque


class Block:
    def __init__(self, author, rnd, payload, qc, id):
        self.author = author
        self.rnd = rnd
        self.payload = payload
        self.qc = qc
        self.id = id
        print(f'\033[1;33m Created new Block class with values au:{self.author} rnd:{self.rnd} pl:{self.payload} id:{self.id} \033[1;37m')


class PendingBlockTree:
    def __init__(self, b):
        if b.qc is None:
            self.root = -1 # setting prev_block_id = -1 for genesis case
        else:
            self.root = b.qc.vote_info.id
        self.blocks = {}  # maps a block_id to a block
        self.blocks[b.id] = b
        print(f'[Val{Safety.validator_id}]\033[1;32m Created new PendingBlockTree class object with root {self.root} and bid {b.id} \033[1;37m')


class PendingBlockTreeQueue:
    def __init__(self):
        self.tree = deque()
        print('PendingBlockTreeQueue object created')

    def add(self, b):
        print('In function PendingBlockTreeQueue.add(); Adding new block to PendingBlockTreeQueue class')
        t = PendingBlockTree(b)
        self.tree.append(t)

    def prune(self, b_id):
        print(f'In function PendingBlockTreeQueue.prune(): attempting prune for block id {b_id}')
        if b_id in self.tree[0].blocks:
            print(f'\033[1;31m Pruning Block {self.tree[0].root}----->{b_id} \033[1;37m for {Safety.validator_id}')
            self.tree.popleft()
        else:
            print('Could not prune: INCONSISTENT STATE')


class LedgerCommitInfo:
    def __init__(self, commit_state_id, vote_info_hash):
        self.commit_state_id = commit_state_id
        self.vote_info_hash = vote_info_hash
        print('Created new LedgerCommitInfo class')


class ProposalMsg:
    def __init__(self, block, last_round_tc, high_commit_qc):
        self.block = block
        self.last_round_tc = last_round_tc
        self.high_commit_qc = high_commit_qc
        self.signature = Safety._private_key.sign(block.id)
        print('Created new ProposalMsg class')


class QC:
    def __init__(self, vote_info, ledger_commit_info, signatures, sender):
        self.vote_info = vote_info
        self.ledger_commit_info = ledger_commit_info
        self.high_commit_qc = high_commit_qc
        self.signatures = signatures
        self.author = sender
        self.author_signature = Safety._private_key.sign(str(signatures).encode())
        print('\033[1;33m Created new QC class \033[1;37m')


class TimeoutMsg:
    def __init__(self, tmo_info, last_round_tc, high_commit_info):
        self.tmo_info = tmo_info
        self.last_round_tc = last_round_tc
        self.high_commit_info = high_commit_info
        print('Created new TimeoutMsg class')


class TC:
    def __init__(self, rnd, tmo_high_qc_rounds, tmo_signatures):
        self.rnd = rnd
        self.tmo_high_qc_rounds = tmo_high_qc_rounds
        self.tmo_signatures = tmo_signatures
        print('Created new TC class')


class TimeoutInfo:
    def __init__(self, rnd, high_qc, sender):
        self.rnd = rnd
        self.high_qc = high_qc
        self.sender = sender
        self.signature = Safety._private_key.sign(high_qc.rnd)
        print('Created new TimeoutInfo class')


class VoteInfo:
    def __init__(self, id, rnd, parent_id, parent_round, exec_state_id):
        self.id = id
        self.rnd = rnd
        self.parent_id = parent_id
        self.parent_round = parent_round
        self.exec_state_id = exec_state_id
        print('Created new VoteInfo class')


class VoteMsg:
    def __init__(self, vote_info, ledger_commit_info, high_commit_qc):
        self.vote_info = vote_info
        self.ledger_commit_info = ledger_commit_info
        self.high_commit_qc = high_commit_qc
        self.sender = Safety.validator_id
        self.signature = Safety._private_key.sign(b'ledger_commit_info')
        print('Created new VoteMsg class')


high_commit_qc = None
high_qc = None
pending_block_tree = PendingBlockTreeQueue()
# Declaring as dictionary for quick search
pending_votes = defaultdict(list)
vote_idx = None
f = 0

def print_pending_block_tree():
    print(f'Printing Pending Block Tree for validator {Safety.validator_id}')
    for ele in pending_block_tree.tree:
        print(f'\033[1;31mValidatorID: {Safety.validator_id} root {ele.root} ->->->->->\033[1;37m' )
        for bl in ele.blocks:
            print(f'\033[1;31mValidatorID: {Safety.validator_id} {bl}\033[1;37m')


def process_qc(qc):
    global pending_block_tree, high_commit_qc, high_qc
    print(f"[Val{Safety.validator_id}]\033In function: process_qc\033[1;37m")
    if (qc is not None) and (qc.ledger_commit_info.commit_state_id is not None) and (qc.vote_info.parent_id not in Ledger.commits):
        # included additional check to prevent committing an already committed block
        Ledger.commit(qc.vote_info.parent_id)
        print(f"[Val{Safety.validator_id}]\033[1;33m Committed block from round {qc.vote_info.parent_round}\033[1;37m")
        print(f'\033[1;32m Calling prune with {qc.vote_info.parent_id} \033[1;37m')
        pending_block_tree.prune(qc.vote_info.parent_id)
        #Reply to client via mempool
        if high_commit_qc is None:
            high_commit_qc = qc
        elif qc.vote_info.rnd > high_commit_qc.vote_info.rnd:
            high_commit_qc = qc
    if high_qc is None:
        high_qc = qc
    elif (qc is not None) and (qc.vote_info.rnd > high_qc.vote_info.rnd):
        high_qc = qc

# sequence of the following function has been changed as we are not maintaining any speculate tree in Ledger


def execute_and_insert(b):
    global pending_block_tree
    print(f'[Val{Safety.validator_id}] In function: execute_and_insert')
    pending_block_tree.add(b)
    print_pending_block_tree()
    if b.qc is None:
        Ledger.speculate(-1, b.id, b.payload)
    else:
        Ledger.speculate(b.qc.vote_info.id, b.id, b.payload)
    print(f'[Val{Safety.validator_id}]>>>>>>Exit: In function: execute_and_insert<<<<<<<<')


def verify_signature(v):
    verify_key = Safety._public_keys[v.sender]
    try:
        verify_key.verify(v.signature)
    except:
        print(f'[Val{Safety.validator_id}]\033[1;37m Incorrect Signature \033[1;37m')
        return False
    return True


def process_vote(v):  # v is of type VoteMsg
    global pending_votes, f
    print(f'[Val{Safety.validator_id}]In function: process_vote')
    process_qc(v.high_commit_qc)
    if verify_signature(v) is True:  # implement code for signature verification
        vote_idx = nacl.hash.sha256((str(v.ledger_commit_info.commit_state_id)+str(v.ledger_commit_info.vote_info_hash)).encode(),\
            nacl.encoding.HexEncoder)
        pending_votes[vote_idx].append([v.sender, v.signature])
        print(f'Pending votes inserted to {vote_idx}')
        if len(pending_votes[vote_idx]) == 2 * f + 1:
            qc = QC(v.vote_info, v.ledger_commit_info, pending_votes[vote_idx], Safety.validator_id)
            return qc
    return None


def generate_block(txns, current_round):
    print(f'[Val{Safety.validator_id}]In function: generate_block')
    global high_qc
    b = 0
    if high_qc is None:
        b = Block(Safety.validator_id, current_round, txns, high_qc, nacl.hash.sha256
              ((str(Safety.validator_id) + str(current_round) + '0' + '0').encode(), nacl.encoding.HexEncoder))
    else:
        b = Block(Safety.validator_id, current_round, txns, high_qc, nacl.hash.sha256
              ((str(Safety.validator_id) + str(current_round) + str(high_qc.vote_info.id) + str(high_qc.signatures)).encode(),\
                  nacl.encoding.HexEncoder))
              #added 0 as integer is required for the hash function
    print(f'\033[1;32m Block created\033[1;37m')
    # qc replaced by high_commit_qc
    return b
