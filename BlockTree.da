import Ledger
import Safety
import PaceMaker
import MemPool
import LeaderElection
from collections import defaultdict
import nacl.hash
import nacl.encoding
from collections import deque


class Block:
    def __init__(self, author, round, payload, qc, id):
        self.author = author
        self.round = round
        self.payload = payload
        self.qc = qc
        self.id = id
        #print(f'{Safety.validator_id}: Created new Block class')


class LedgerCommitInfo:
    def __init__(self, commit_state_id, vote_info_hash):
        self.commit_state_id = commit_state_id
        self.vote_info_hash = vote_info_hash
        #print(f'{Safety.validator_id}: Created new LedgerCommitInfo class.')


class ProposalMsg:
    def __init__(self, block, last_round_tc, high_commit_qc):
        self.block = block
        self.last_round_tc = last_round_tc
        self.high_commit_qc = high_commit_qc
        # signing_key expected in Safety module
        self.signature = Safety.get_private_key().sign(block.id.encode())
        #print(f'{Safety.validator_id}: Created new ProposalMsg class')


class QC:
    def __init__(self, vote_info, ledger_commit_info, signatures, author):
        self.vote_info = vote_info
        self.ledger_commit_info = ledger_commit_info
        self.high_commit_qc = high_commit_qc
        self.signatures = signatures
        self.author = author
        # self.author_signature = Safety.signing_key.sign(
        #    signatures)  # signing_key expected in Safety module
        if signatures:
            self.author_signature = Safety.get_private_key().sign(
                b''.join([signature for (signer, signature) in signatures]))
        else:
            self.author_signature = None
        #print(f'{Safety.validator_id}: Created new QC class')

    def signers(self):
        #print(f"{Safety.validator_id}: Inside function BlockTree.QC.signers.")
        # return signers of this QC (actual process, not just ID)
        try:
            qc_signers = [Safety.validator_map[val]
                          for (val, _) in self.signatures]
        except:
            print(f"Error getting qc signers. {Safety.validator_id}")
        return qc_signers


class TimeoutMsg:
    def __init__(self, tmo_info, last_round_tc, high_commit_qc):
        self.tmo_info = tmo_info
        self.last_round_tc = last_round_tc
        self.high_commit_qc = high_commit_qc
        #print(f'{Safety.validator_id}: Created new TimeoutMsg class')


class TC:
    def __init__(self, round, tmo_high_qc_rounds, tmo_signatures):
        self.round = round
        self.tmo_high_qc_rounds = tmo_high_qc_rounds
        self.tmo_signatures = tmo_signatures
        #print(f'{Safety.validator_id}: Created new TC class')


class TimeoutInfo:
    def __init__(self, round, high_qc, sender):
        self.round = round
        self.high_qc = high_qc
        self.sender = sender
        # signing_key expected in Safety module
        self.signature = Safety.get_private_key().sign((round, high_qc.vote_info.round))
        #print(f'{Safety.validator_id}: Created new TimeoutInfo class')


class VoteInfo:
    def __init__(self, id, round, parent_id, parent_round, exec_state_id):
        self.id = id
        self.round = round
        self.parent_id = parent_id
        self.parent_round = parent_round
        self.exec_state_id = exec_state_id
        #print(f'{Safety.validator_id}: Created new VoteInfo class')


class VoteMsg:
    def __init__(self, vote_info, ledger_commit_info, high_commit_qc):
        self.vote_info = vote_info
        self.ledger_commit_info = ledger_commit_info
        self.high_commit_qc = high_commit_qc
        self.sender = Safety.validator_id
        # signing_key expected in Safety module
        if ledger_commit_info.commit_state_id:
            self.signature = Safety.get_private_key().sign(
                (ledger_commit_info.commit_state_id+ledger_commit_info.vote_info_hash).encode())
        else:
            self.signature = Safety.get_private_key().sign(
                (ledger_commit_info.vote_info_hash).encode())
        #print(f'{Safety.validator_id}: Created new VoteMsg class')


class BlockNode:
    def __init__(self, block, children=None):
        self.block = block
        if children is None:
            self.children = []


high_commit_qc = None
high_qc = None
pending_block_tree = {}  # Use a dictionary, indexed by block id
# Declaring as dictionary for quick search
pending_votes = defaultdict(list)
vote_idx = None
f = None

genesis_block = None


# Must be called after Safety is setup
def setup_BlockTree():
    global f, high_qc, genesis_block
    f = Safety.f
    # Create genesis block and genesis QC (to link to genesis block for advancement from round 0)
    # genesis block is the root of the pending blocktree
    genesis_blockid = nacl.hash.sha256(str(666).encode()).decode()
    genesis_block = Block(author=None, round=0, payload='',
                          qc=None, id=genesis_blockid)

    # should everyone start with QC(0), or only leader embed it in Block(1)?
    # try everyone starting with it
    genesis_qc_vote_info = VoteInfo(
        id=genesis_blockid, round=0, parent_id=None, parent_round=None, exec_state_id=None)
    genesis_qc = QC(vote_info=genesis_qc_vote_info,
                    ledger_commit_info=None, signatures=None, author=None)
    genesis_block_node = BlockNode(genesis_block)
    pending_block_tree[genesis_blockid] = genesis_block_node
    high_qc = genesis_qc


def pending_block_tree_prune(newroot_id):
    global pending_block_tree
    print(f"\t\t\t\tPREV PENDING_BLOCK_TREE:{pending_block_tree}")
    nodes_to_keep = []
    children = pending_block_tree[newroot_id].children
    while (len(children) > 0):
        curr = children.pop(0)
        if curr == None:
            continue
        nodes_to_keep.append(pending_block_tree[curr])
        # keep its children as well
        children += pending_block_tree[curr].children
    pending_block_tree.clear()
    for node in nodes_to_keep:
        pending_block_tree[node.block.id] = node

    print(f"\t\t\t\tCURRENT PENDING_BLOCK_TREE:{pending_block_tree}")


def process_qc(qc):
    global pending_block_tree, high_commit_qc, high_qc
    #print(f'{Safety.validator_id}: In function: process_qc.')
    committed_request = None
    # If received genesis QC and round is 0, return because genesis QC is already highqc and has no info
    if qc.vote_info.round == 0 and PaceMaker.current_round == 1:
        return

    if qc.ledger_commit_info.commit_state_id and (qc.vote_info.parent_id not in Ledger.commits):
        # included additional check to prevent committing an already committed block
        print(
            f"{Safety.validator_id}: Committing block cmd,round: {pending_block_tree[qc.vote_info.parent_id].block.payload,qc.vote_info.parent_round}")
        committed_request = Ledger.commit(qc.vote_info.parent_id)
        try:
            # remove pending request from mempool
            MemPool.pending_requests.remove(
                pending_block_tree[qc.vote_info.parent_id].block.payload)
            if Safety.validator_id == str(LeaderElection.get_leader(PaceMaker.current_round+1)) and len(MemPool.pending_requests) == 0:
                # Since this may empty the pending requests pool, leader may not propose an empty block to allow other
                # validators who don't have this qc to commit the commit_state_id. This variable ensures other validators
                # get the qc
                MemPool.progress_pending_cmd = True
            if committed_request:
                # pass
                # prune
                pending_block_tree_prune(qc.vote_info.parent_id)

        except:
            #print(f"{Safety.validator_id}: payload:{pending_block_tree[qc.vote_info.parent_id].payload},pending:{MemPool.pending_requests}. {Safety.validator_id}")
            pass

        if high_commit_qc:
            if qc.vote_info.round > high_commit_qc.vote_info.round:
                high_commit_qc = qc
        else:
            high_commit_qc = qc

    if qc.vote_info.round > high_qc.vote_info.round:
        high_qc = qc
    return committed_request

# sequence of the following function has been changed as we are not maintaining any speculate tree in Ledger


def execute_and_insert(b):
    global pending_block_tree
    #print(f'{Safety.validator_id}: In function: execute_and_insert.')
    Ledger.speculate(b.qc.vote_info.id, b.id, b.payload)
    block_node = BlockNode(b)
    pending_block_tree[b.id] = block_node
    # Add itself to children of parent block (simulating a tree)
    pending_block_tree[b.qc.vote_info.id].children.append(b.id)


def verify_signature(v):
    ##print(f"{Safety.validator_id}: Inside BlockTree.verify_signature")
    verify_key = Safety.get_public_key(v.sender)
    if verify_key == None:
        return False
    try:
        verify_key.verify(v.signature)
    except:
        print('Incorrect Signature')
        return False
    return True


def process_vote(v):  # v is of type VoteMsg
    global pending_votes, f
    #print(f'{Safety.validator_id}: In function: process_vote')
    if v.high_commit_qc != None:
        process_qc(v.high_commit_qc)
    commit_state_id = v.ledger_commit_info.commit_state_id
    if commit_state_id:
        vote_idx = nacl.hash.sha256(
            (v.ledger_commit_info.commit_state_id+v.ledger_commit_info.vote_info_hash).encode()).decode()
    else:
        vote_idx = nacl.hash.sha256(
            (v.ledger_commit_info.vote_info_hash).encode()).decode()
    if verify_signature(v):
        pending_votes[vote_idx].append((v.sender, v.signature))
        if len(pending_votes[vote_idx]) == 2 * f + 1:
            #print("Making QC")
            qc = QC(v.vote_info, v.ledger_commit_info, pending_votes[vote_idx],
                    Safety.validator_id)
            #print(f'{Safety.validator_id}: Created quorum certificate')
            return qc
    return None


def generate_block(txns, current_round):
    global high_commit_qc, high_qc
    #print(f'{Safety.validator_id}: In function: generate_block')
    qc = high_qc
    segment_1 = nacl.hash.sha256(
        ((Safety.validator_id)+"-"+str(current_round)+"-"+txns+str(qc.vote_info.id)).encode())
    if qc.vote_info.round == 0:
        # no signatures in the genesis QC, so skip segment 2
        segment_2 = b''
    else:
        segment_2 = nacl.hash.sha256(
            b''.join([str(signer).encode()+sig for (signer, sig) in qc.signatures]))

    block_id = nacl.hash.sha256(segment_1 + segment_2).decode()
    b = Block(author=Safety.validator_id, round=current_round,
              payload=txns, qc=qc, id=block_id)
    return b
