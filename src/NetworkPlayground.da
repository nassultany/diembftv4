import ValidatorTwins
from pathlib import Path
import os
import datetime


config(channel='fifo', clock='Lamport')


class NetworkPlayground(process):
    def setup(config):
        self.test_case_name = config['test_case_name']
        self.validators = config['validators']
        self.validator_id_to_process = config['validator_id_to_process']
        self.finished = False
        self.executor = config['executor']
        self.partitions = config['partitions']
        self.intercepted_messages = {
            "ProposalMsg": [], "TimeoutMsg": [], "VoteMsg": [], "LocalTimeout": []}
        log_folder = Path("./log")
        os.makedirs(log_folder, exist_ok=True)
        fname = self.test_case_name + '_' + 'NetworkPlayground.log'
        self.log_path = log_folder / fname
        file = open(self.log_path, "w")
        file.close()

    def log(content):
        file = open(log_path, "a")
        log_str = datetime.datetime.now().strftime("%H:%M:%S") + " " + \
            str(content) + '\n'
        file.write(log_str)
        file.close()

    def receive(msg=("WaitForMessages", (num, msg_type)), from_=test_executor):
        output(
            f"Waiting for {num} {msg_type}(s). Currently have {len(intercepted_messages[msg_type])}")
        await(len(intercepted_messages[msg_type]) > num or finished)
        if not finished:
            # take out the [0] if you want to actually send the whole list. May need to increase message
            # buffer size.
            send(
                ("GotMessages", intercepted_messages[msg_type][0]), to=test_executor)

    def receive(msg=("TerminateValidators",), from_=test_executor):
        output("Got TerminateValidators from executor.")
        self.finished = True

    def receive(msg=("RunDone",), from_=test_executor):
        output("Got RunDone from test executor.")
        self.finished = True

    def receive(msg=("ProposalMsg", P, sender_id), from_=sender):
        if finished:
            return
        intercepted_messages["ProposalMsg"].append((P, sender_id))
        log(f"Intercepted ProposalMsg from {sender_id}: {P}")
        #send(("ProposalMsg", P, sender_id), to=validators)
        msg_round = P.block.round
        if msg_round > len(partitions):
            #output("No partitions for this round")
            send(("ProposalMsg", P, sender_id), to=validators)
        else:
            deliver_message("ProposalMsg", msg_round, P, sender_id)

    def receive(msg=("TimeoutMsg", M, sender_id), from_=sender):
        if finished:
            return
        intercepted_messages["TimeoutMsg"].append((M, sender_id))
        log(f"Intercepted TimeoutMsg from {sender_id}: {M}")
        #send(("TimeoutMsg", M, sender_id), to=validators)
        msg_round = M.tmo_info.round
        deliver_message("TimeoutMsg", msg_round, M, sender_id)

    def receive(msg=("VoteMsg", M, sender_id, next_rnd_leader), from_=sender):
        if finished:
            return
        intercepted_messages["VoteMsg"].append((M, sender_id, next_rnd_leader))
        log(f"Intercepted VotetMsg from {sender_id} to {next_rnd_leader}: {M}")
        #send(("VoteMsg", M, sender_id),to=validator_id_to_process[next_rnd_leader])
        msg_round = M.vote_info.round
        if msg_round > len(partitions):
            #output("No partitions for this round.")
            send(("VoteMsg", M, sender_id),
                 to=validator_id_to_process[next_rnd_leader])
        else:
            deliver_message("VoteMsg", msg_round, M,
                            sender_id, next_rnd_leader)

    # nxt_rnd_leader is only used in the case of VoteMsg, where there is a specific target
    def deliver_message(msg_type, msg_round, M, sender_id, nxt_rnd_leader=None):
        if msg_type == "ProposalMsg":
            for partition in partitions[msg_round-1]:
                # [-1] to extract just the letter from whole id. Ex: Validator_A -> A
                if sender_id[-1] in partition:
                    recipients = {
                        validator_id_to_process["Validator_"+letter_id] for letter_id in partition}
                    log(f"Delivering {msg_type} from {sender_id} to {partition}")
                    send((msg_type, M, sender_id), to=recipients)
                    return
        elif msg_type == "VoteMsg":
            for partition in partitions[msg_round-1]:
                if sender_id[-1] in partition:
                    if nxt_rnd_leader[-1] in partition:
                        log(
                            f"Delivering {msg_type} from {sender_id} to {nxt_rnd_leader[-1]}")
                        send((msg_type, M, sender_id),
                             to=validator_id_to_process[nxt_rnd_leader])
                    else:
                        return
        elif msg_type == "TimeoutMsg":
            # should not drop timeout messages (unless explicitly specified)
            log(f"Delivering {msg_type} from {sender_id} to {validators}")
            send((msg_type, M, sender_id), to=validators)
        else:
            output("Error in NetworkPlayground.deliver_messsage")

    def run(self):
        output(f"Running test case: {test_case_name}")

        await(finished)

        await(each(v in validators, has=received(('Exiting',), from_=v)))
        send(('finished_test_case',), to=executor)
        output(f"Finished test case: {test_case_name}")
