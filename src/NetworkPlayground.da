import Validator
from nacl.signing import SigningKey

config(channel='fifo', clock='Lamport')

class NetworkPlayground(process):
    def setup(nodes, te, twins, param_round_partitions, round_leaders, msg_type_drps, intra_prt_drops):

        self.round_partitions = param_round_partitions  # map from round number to partitions (ex: 3:[{A,B,C},{A',D}])
        self.intercepted_msgs = [0]*4  # map from message type to list of intercepted messages of that type
        self.honest_twin_map = {}  # map from a node to its twin for all twin nodes
        self.validators = set() # set of all validator processes
        self.node_name_proc_map = {}  # map from a node name to a process, including twins
        self.node_proc_name_map = {} # map from a process to a node, including twins
        self.commit_info = {}  # maps node name with its commit_state_id
        self.end_flag = False # indicates when there are no more test cases
        self.msg_type_drops = msg_type_drps
        self.intra_partition_drops = intra_prt_drops
        self.twin_nodes = twins
        self.te = te

        self.private_keys = {}
        self.public_keys = {}

        for i,node in enumerate(nodes):
            if node not in twins:
                private_keys[node] = SigningKey.generate()
            else:
                # private key of a twin node is the same as its original counterpart
                honest_twin_map[node] = twins[i]
                private_keys[honest_twin_map[node]] = private_keys[node]
            public_keys[node] = private_keys[node].verify_key() 

        validators = new(Validator.Validator, num=nodes.size())
        node_name_proc_map = {nodes[i]: val for i, val in enumerate(validators)}
        node_proc_name_map = {v: k for k, v in node_name_proc_map.items()}

        for node, proc in node_name_proc_map.items():
            config = {}
            config['validator_id'] = node
            config['private_key'] = private_keys[node]
            config['public_keys'] = public_keys
            config['f'] = False
            # has to be list so that PaceMaker can deterministically choose a leader in case of round robin
            config['validator_ids'] = nodes # list of validator ids
            config['round_leaders'] = round_leaders
            config['validator_id_to_process'] = node_name_proc_map
            config['validator_process_to_id'] = node_proc_name_map
            # config['parent'] = self
            # config['client_keys'] = client_public_keys
            setup(proc, (validators - {proc}, 0, config)) 

    # gives numeric code for particular message type

    def get_msg_code(msg_type):
        if msg_type == "ProposalMsg":
            return 0
        if msg_type == "VoteMsg":
            return 1
        if msg_type == "TimeoutMsg":
            return 2
        if msg_type == "TxnCompletedMsg":
            return 3

    # NetworkPlayground : EventLoop
    # loop: wait for next event M ; NetworkPlayground.start_event_processing(M)

    def receive(msg=(M), from_=sender):
        if M[0] == "ProposalMsg":
            if node_proc_name_map[sender] not in twin_nodes:
                # intercepted_msgs[get_msg_code("ProposalMsg")].append(M[1])
                # reset intercepted messages list to symbolise beginning of next round
                intercepted_msgs = [0]*4
                intercepted_msgs[get_msg_code("ProposalMsg")] += 1
            deliver_message(M)

        if M[0] == "VoteMsg":
            # intercepted_msgs[get_msg_code("VoteMsg")].append(M[1])
            intercepted_msgs[get_msg_code("VoteMsg")] += 1
            if intercepted_msgs[get_msg_code("VoteMsg")] == 2*len(twin_nodes):
                send("VoteMsg", te)
            deliver_message(M)

        if M[0] == "TimeoutMsg":
            # intercepted_msgs[get_msg_code("TimeoutMsg")].append(M[1])
            intercepted_msgs[get_msg_code("TimeoutMsg")] += 1
            if intercepted_msgs[get_msg_code("TimeoutMsg")] == 2*len(twin_nodes):
                send("TimeoutMsg", te)
            deliver_message(M)

        if M[0] == "TxnCompletedMsg":
            intercepted_msgs[get_msg_code("TxnCompletedMsg")] += 1 
            deliver_message(M)

    # This function waits until a certain number of messages of a certain type have been
    # intercepted by the playground, and then returns them; used in executor

    def wait_for_messages(num, msgtype):
        await(len(intercepted_msgs[msgtype]) >= num)
        return intercepted_msgs[msgtype]


    def deliver_message(M):
        global honest_twin_map
        if M[0] == "ProposalMsg":
            msg_sender = M.sender
            msg_rnd = M.block.round
            if msg_type_drops[msg_rnd] == 'P':
                return  # drop proposal message
            if intra_partition_drops[msg_rnd] == True:
                return  # drop message within partition
            for partition in round_partitions[msg_rnd]:
                if msg_sender in partition:
                    receivers = set(node_name_proc_map[node] for node in partition)
                    send(M, receivers)
                    return
        if M[0] == "VoteMsg":
            msg_sender = M.sender
            msg_rnd = M.vote_info.round
            msg_recipient = M.recipient  # node this vote message was intended to go to
            if msg_type_drops[msg_rnd] == 'V':
                return  # drop proposal message
            if intra_partition_drops[msg_rnd] == True:
                return  # drop message within partition
            for partition in round_partitions[msg_rnd]:
                if msg_sender in partition:
                    if msg_recipient in partition:
                        send(M, msg_recipient)
                    if honest_twin_map[msg_recipient] in partition:
                        send(M, honest_twin_map[msg_recipient])
            if msg_rnd is len(round_leaders):
                end_flag = True
            return

        # timeout messages should never be dropped in order to allow nodes to create TCs
        # to advance rounds and progress the test case

        if M[0] == "TimeoutMsg":
            if intra_partition_drops[msg_rnd] == True:
                return  # drop message within partition
            send(M, validators)
            return

        if M[0] == "TransactionCompletedMsg":
            commit_info[M.sender] = M.commit_state_id

    def run(self):
        start(validators)
        await(end_flag is True)
        send(('RunDone',), to=validators)
        await(each(v in validators, has=received(('Exiting',), from_=v)))
        send(('RunDone',commit_info), to=te)
        # send(('finished_test_case',), to=self)
        output(f"Finished twins test cases")