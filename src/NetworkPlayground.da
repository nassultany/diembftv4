import ValidatorTwins
from pathlib import Path
import os
import datetime


config(channel='fifo', clock='Lamport')


class NetworkPlayground(process):
    def setup(config):
        self.test_case_name = config['test_case_name']
        self.validators = config['validators']
        self.validator_id_to_process = config['validator_id_to_process']
        self.finished = False
        self.executor = config['executor']
        self.intercepted_messages = {
            "ProposalMsg": [], "TimeoutMsg": [], "VoteMsg": [], "LocalTimeout": []}
        log_folder = Path("./log")
        os.makedirs(log_folder, exist_ok=True)
        fname = self.test_case_name + '_' + 'NetworkPlayground.log'
        self.log_path = log_folder / fname
        file = open(self.log_path, "w")
        file.close()

    def log(content):
        file = open(log_path, "a")
        log_str = datetime.datetime.now().strftime("%H:%M:%S") + " " + \
            str(content) + '\n'
        file.write(log_str)
        file.close()

    def receive(msg=("WaitForMessages", (num, msg_type)), from_=test_executor):
        output(
            f"Waiting for {num} {msg_type}(s). Currently have {len(intercepted_messages[msg_type])}")
        await(len(intercepted_messages[msg_type]) > num or finished)
        if not finished:
            output("Got that many messages")
            send(
                ("GotMessages", intercepted_messages[msg_type][0]), to=test_executor)

    def receive(msg=("TerminateValidators",), from_=test_executor):
        output("Got TerminateValidators from executor.")
        self.finished = True

    def receive(msg=("RunDone",), from_=test_executor):
        output("Got RunDone from test executor.")
        self.finished = True

    def receive(msg=("ProposalMsg", P, sender_id), from_=sender):
        if finished:
            return
        intercepted_messages["ProposalMsg"].append((P, sender_id))
        log(f"Intercepted ProposalMsg from {sender_id}: {P}")
        send(("ProposalMsg", P, sender_id), to=validators)

    def receive(msg=("TimeoutMsg", M, sender_id), from_=sender):
        if finished:
            return
        intercepted_messages["TimeoutMsg"].append((M, sender_id))
        log(f"Intercepted TimeoutMsg from {sender_id}: {M}")
        send(("TimeoutMsg", M, sender_id), to=validators)

    def receive(msg=("VoteMsg", M, sender_id, next_rnd_leader), from_=sender):
        if finished:
            return
        intercepted_messages["VoteMsg"].append((M, sender_id, next_rnd_leader))
        log(f"Intercepted VotetMsg from {sender_id} to {next_rnd_leader}: {M}")
        send(("VoteMsg", M, sender_id),
             to=validator_id_to_process[next_rnd_leader])

    def run(self):
        output(f"Running test case: {test_case_name}")

        if await(finished):
            pass
        elif timeout(5):
            output("Timed out waiting for executor to tell me to wrap it up.")

        await(each(v in validators, has=received(('Exiting',), from_=v)))
        send(('finished_test_case',), to=executor)
        output(f"Finished test case: {test_case_name}")
