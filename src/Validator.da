import BlockTree
import LeaderElection
import Ledger
import MemPool
import PaceMaker
import Safety
import os
import sys
from time import sleep

config(channel='fifo', clock='Lamport')


class Validator(process):
    def setup(validators: set, exit_cnt: int, config):
        # output("Setting up validator")
        Safety.set_private_key(config['private_key'])
        Safety.set_public_keys(config['public_keys'])
        Safety.validator_id = str(self)
        Safety.validator_name = config['validator_name']
        Safety.f = (config['f'])
        Safety.validators = config['validators']
        Safety.validator_map = config['validator_map']
        Safety.log_path = os.path.abspath('..\\log\\' + Safety.validator_name + '.log')
        file = open(Safety.log_path, "w")
        file.close()
        LeaderElection.setup_LeaderElection()  # Must be called after Safety is setup
        BlockTree.setup_BlockTree()  # Must be called after Safety is setup
        Ledger.setup_Ledger()  # Must be called after Safety is setup
        MemPool.clients = config['client_map']
        self.run_done = False
        self.round_start = False
        self.round_stop = False
        self.faulty = config['faulty']
        Safety.log("Initialized from config:", f"private_key: {config['private_key']}")
        Safety.log("Initialized from config:", f"public_keys: {config['public_keys']}")
        Safety.log("Initialized from config:", f"validator_id: {str(self)}")
        Safety.log("Initialized from config:", f"validator_name: {config['validator_name']}")
        Safety.log("Initialized from config:", f"f: {config['f']}")
        Safety.log("Initialized from config:", f"validators: {config['validators']}")
        Safety.log("Initialized from config:", f"validator_map: {config['validator_map']}")
        Safety.log("Initialized from config:", f"clients: {config['client_map']}")
        Safety.log("Initialized from config:", f"faulty: {config['faulty']}")

    # sends a message to another validator
    def send_message(msg_type, msg_object, recipient):
        send((msg_type, msg_object), to=recipient)
        # Safety.log("Sent message:", f"{msg_type}: {str(msg_object)} to {recipient}")

    def send_reply(cmd):
        result = "Your cmd: " + cmd + " was committed by " + str(self)
        client_str = cmd.split('-')[0]
        reqid = int(cmd.split('-')[1])
        client = MemPool.clients[client_str]
        MemPool.cache_reply(cmd, result)
        # output(f"Sending reply to {client} for {cmd}")
        send(('Reply', (reqid, result)), to=client)
        Safety.log("Sent Reply:", f"recipient: {client} command: {cmd}")

    # PSEUDOCODE: Procedure process_certificate_qc(qc)
    def process_certificate_qc(qc):
        if qc is None:
            # output("Empty qc")
            return
        # output(f'In function: process_certificate_qc.')

        # PSEUDOCODE: Block-Tree.process_qc(qc)
        committed_request = BlockTree.process_qc(qc)
        if committed_request:
            # send reply to the client
            if committed_request != '':
                send_reply(committed_request)

        # PSEUDOCODE: LeaderElection.update_leaders(qc)
        LeaderElection.update_leaders(qc)

        # PSEUDOCODE: PaceMaker.advance_round(qc.vote_info.round)
        if PaceMaker.advance_round_qc(qc):
            round_stop = True
            output(f"Stopping round because of qc.")
            if len(MemPool.pending_requests) > 1 ^ ('' not in MemPool.pending_requests):
                # start new round timer
                output(
                    f"Starting round {PaceMaker.current_round} timer because of pending request. {MemPool.pending_requests}, commits:{[x.payload for x in Ledger.commits.values()]}")
                round_start = True

    # PSEUDOCODE: Procedure process_proposal_msg(P)
    def process_proposal_msg(P, sender, signature):
        #Check signature of sender first
        if not Safety._valid_signature(Safety.get_public_key(str(sender)), signature):
            output('Not correct signature, Message will not be processed')
        # output('In function: process_proposal_msg.')
        # remove the request from your request pool so you don't propose it again
        MemPool.remove_from_requests(P.block.payload)
        MemPool.pending_requests.add(P.block.payload)

        # PSEUDOCODE: process_certificate_qc(P.block.qc)
        process_certificate_qc(P.block.qc)

        # PSEUDOCODE: process_certificate_cq(P.high_commit_qc)
        process_certificate_qc(P.high_commit_qc)

        # PSEUDOCODE: PaceMaker.advance_round_tc(P.last_round_tc)
        if PaceMaker.advance_round_tc(P.last_round_tc):
            round_stop = True
            if len(MemPool.pending_requests) > 1 ^ ('' not in MemPool.pending_requests):
                round_start = True

        # PSEUDOCODE: round <- PaceMaker.current_round
        current_round = PaceMaker.current_round

        # PSEUDOCODE: leader <- LeaderElection.get_leader(current_round)
        leader = LeaderElection.get_leader(current_round)

        # PSEUDOCODE: if P.block.round != round or P.sender != leader or P.block.author != leader then
        #               return
        if (P.block.round != current_round) or (sender != leader) or (P.block.author != str(leader)):
            output("Error here")
            print(P.block.round, current_round, str(leader),
                  str(sender), P.block.author, leader)
            # remove it from requests and pending?
            MemPool.remove_from_requests(P.block.payload)
            MemPool.pending_requests.remove(P.block.payload)
            return

        # PSEUDOCODE: Block-Tree.execute_and_insert(P)
        BlockTree.execute_and_insert(P.block)

        # PSEUDOCODE: vote_msg < - Safety.make_vote(P.block, P.last_round_tc)
        vote_msg = Safety.make_vote(P.block, P.last_round_tc)

        # PSEUDOCODE: if vote_msg != None then
        if vote_msg is not None:
            # output(f"Sending vote to leader of round {current_round+1}: {LeaderElection.get_leader(current_round+1)}.")

            # PSEUDOCODE: send vote_msg to LeaderElection.get_leader(current_round + 1)
            send(("VoteMsg", vote_msg),
                 to=LeaderElection.get_leader(current_round + 1))
        else:
            output(f"Empty vote message.")

    # PSEUDOCODE: Procedure process_timeout_msg(M)
    def process_timeout_msg(M):
        # output('In function: process_timeout_msg')

        # PSEUDOCODE: process_certificate_qc(M.tmo_info.high_qc)
        process_certificate_qc(M.tmo_info.high_qc)

        # PSEUDOCODE: process_certificate_qc(M.high_commit_qc)
        process_certificate_qc(M.high_commit_qc)

        # PSEUDOCODE: PaceMaker.advance_round_tc(M.last_round_tc)
        if PaceMaker.advance_round_tc(M.last_round_tc):
            round_stop = True
            if len(MemPool.pending_requests) > 1 ^ ('' not in MemPool.pending_requests):
                round_start = True

        # PSEUDOCODE: tc <- PaceMaker.process_remote_timeout(M)
        tc, M = PaceMaker.process_remote_timeout(M)

        # PSEUDOCODE: if tc != None then
        if tc:
            # PSEUDOCODE: PaceMaker.advance_round(tc)
            if PaceMaker.advance_round_tc(tc):
                output(f"Advancing, but not starting, round because of tc.")
                round_stop = True
                if len(MemPool.pending_requests) > 1 ^ ('' not in MemPool.pending_requests):
                    output(
                        f"Starting round {PaceMaker.current_round} timer because of pending request. {MemPool.pending_requests}, commits:{[x.payload for x in Ledger.commits.values()]}")
                    round_start = True

            # PSEUDOCODE: process_new_round_event(tc)
            process_new_round_event(tc)
        elif M:
            round_stop = True
            output("Stopping round due to bracha timeout.")
            send(("TimeoutMsg", M), to=validators)

    # PSEUDOCODE: Procedure process_vote_msg(M)
    def process_vote_msg(M):
        # output(f'In function: process_vote_msg.')
        if not Safety._valid_signature(Safety.get_public_key(str(M.sender)), M.signature):
            output('Not correct signature, Message will not be processed')

        # PSEUDOCODE: qc <- Block-Tree.process_vote(M)
        qc = BlockTree.process_vote(M)

        # PSEUDOCODE: if qc != None then
        if qc is not None:
            # PSEUDOCODE: process_certificate_qc(qc)
            process_certificate_qc(qc)

            # PSEUDOCODE: process_new_round_event(None)
            process_new_round_event(None)

    # PSEUDOCODE: Procedure process_new_round_event(last_tc)
    def process_new_round_event(last_tc):
        # output(f'In function: process_new_round_event.')
        current_round = PaceMaker.current_round

        # output(f"The leader for round {current_round} is {leader}")

        # PSEUDOCODE: if u = LeaderElection.get_leader(PaceMaker.current_round) then
        if self == LeaderElection.get_leader(PaceMaker.current_round):
            # if no pending transactions, don't propose empty blocks, but rather wait for requests to come in
            if len(MemPool.pending_requests) == 0:
                # No pending requests (pending = submitted but not yet proposed or committed)
                # wait for requests to come in

                # output("Waiting for requests/transactions to be submitted by clients...")
                -- wait_for_requests
                await((len(MemPool.pending_requests) > 1 ^ (
                        '' not in MemPool.pending_requests)) or MemPool.progress_pending_cmd or run_done)
                # await((len(MemPool.pending_requests) > 1 ^ ('' not in MemPool.pending_requests)) or run_done)
            if run_done:
                # allow validator to exit
                return
            MemPool.progress_pending_cmd = False

            # PSEUDOCODE: b <- Block-Tree.generate_block(MemPool.get_transaction(), PaceMaker.current_round)
            b = BlockTree.generate_block(
                MemPool.get_transactions(), PaceMaker.current_round)

            P = BlockTree.ProposalMsg(b, last_tc, BlockTree.high_commit_qc)

            # simulate faulty leader
            if faulty:
                output(
                    f"SLEEPING WHEN I SHOULD BE DOING SENDING BLOCK FOR ROUND: {PaceMaker.current_round}")
                sleep(8)
                faulty = False

            # should send itself the proposal as well
            # PSEUDOCODE: broadcast ProposalMsg(b, last_tc, Block - Tree.high_commit_qc)
            signature = Safety.get_private_key().sign((str(P).encode()))
            send(("ProposalMsg", P, signature), to=validators.union({self}))

    # PSEUDOCODE: if M is a proposal message then process_proposal_msg(M)
    def receive(msg=("ProposalMsg", P, signature), from_=sender):
        process_proposal_msg(P, sender, signature)
        Safety.log("Received ProposalMsg:",
                   f"sender: {sender}, block: {P.block}, block_author: {P.block.author}, block_round: {P.block.round}, block_payload: {P.block.payload}, block_qc: {P.block.qc}, block_id: {P.block.id} last_round_tc: {P.last_round_tc}, high_commit_qc: {P.high_commit_qc}, signature: {P.signature}")

    # PSEUDOCODE: if M is a timeout message then process_timeout_message(M)
    def receive(msg=("TimeoutMsg", M), from_=sender):
        process_timeout_msg(M)
        Safety.log("Received TimeoutMsg:",
                   f"sender: {sender}, tmo_info:{M.tmo_info}, tmo_info_round: {M.tmo_info.round}, tmo_info_high_qc: {M.tmo_info.high_qc}, tmo_info_sender: {M.tmo_info.sender}, tmo_info_signature: {M.tmo_info.signature}, last_round_tc: {M.last_round_tc}, high_commit_qc: {M.high_commit_qc}")

    # PSEUDOCODE: if M is a vote message then process_vote_msg(M)
    def receive(msg=("VoteMsg", M), from_=sender):
        process_vote_msg(M)
        Safety.log("Received VoteMsg:",
                   f"sender: {sender}, vote_info: {M.vote_info}, vote_info_id: {M.vote_info.id}, vote_info_round: {M.vote_info.round}, vote_info_parent_id: {M.vote_info.parent_id}, vote_info_exec_state_id: {M.vote_info.exec_state_id}, ledger_commit_info: {M.ledger_commit_info}, high_commit_qc: {M.high_commit_qc}, signature: {M.signature}")

    # PSEUDOCODE: if M is a local timeout then Pacemaker.local_timeout_round()
    def receive(msg=("LocalTimeout", M), from_=sender):
        PaceMaker.local_timeout_round()
        Safety.log("Received LocalTimeout:", f"sender: {sender}, message:{M}")

    def receive(msg=('Request', req), from_=sender):
        # output(f"Received request from {sender}.")
        Safety.log("Received Request:", f"sender: {sender}, id:{req.id}, cmd: {req.cmd}, signature: {req.signature}")
        Reply = MemPool.add_request(req)
        if Reply:
            # request already committed, send cached response
            output("Request already committed, sending cached response.")
            send(('Reply', Reply), to=req.client)
        else:
            if round_stop == True and round_start == False:
                round_stop = False
                round_start = True

    def receive(msg=('RunDone',), from_=p):
        run_done = True
        Safety.log("Received RunDone:", f"sender: {sender}")

    def run(self):
        output("Starting up...")
        self.process_new_round_event(None)  # jumpstart algorithm
        # await(run_done and len(MemPool.pending_requests) == 0)
        while not run_done:
            while not round_start:
                -- process_messages_while_waiting_to_start_round
                if run_done:
                    break
                pass
            output(f"Round {PaceMaker.current_round} started.")
            round_start = False
            timer_duration = PaceMaker.get_round_timer(PaceMaker.current_round)
            if await round_stop:
                output(f"Round {PaceMaker.current_round} stopped.")
                pass
            elif timeout(timer_duration):
                output(f"Timing out in round {PaceMaker.current_round}")
                M = PaceMaker.local_timeout_round()
                send(("TimeoutMsg", M), to=validators.union({self}))

        output(f"Exiting: {Safety.validator_name}")
        # Safety.log_file.close()
        Safety.log("Exit:", Safety.validator_name)
